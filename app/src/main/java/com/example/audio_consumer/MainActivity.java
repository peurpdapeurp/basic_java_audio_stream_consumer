
package com.example.audio_consumer;

import androidx.appcompat.app.AppCompatActivity;

import android.media.AudioFormat;
import android.media.MediaCodec;
import android.media.MediaCodecInfo;
import android.media.MediaExtractor;
import android.media.MediaFormat;
import android.os.Bundle;
import android.provider.MediaStore;
import android.util.Log;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.Arrays;

public class MainActivity extends AppCompatActivity {

    private static final String TAG = "MainActivity";

    private static final int INFINITE_WAIT = -1;

    private static final int
        FRAME_TO_EXTRACT = 0;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        AACADTSFrameSource frameSource = new AACADTSFrameSource(TestFrames.MUSIC_ADTS_FRAME_BUFFERS[FRAME_TO_EXTRACT]);
        int samplingRate = 0, numChannels = 0;
        byte[] csd0 = null;

        try {

            MediaExtractor extractor = new MediaExtractor();
            extractor.setDataSource(frameSource);
            int numTracks = extractor.getTrackCount();
            for (int j = 0; j < numTracks; j++) {
                MediaFormat format = extractor.getTrackFormat(j);
                String mime = format.getString(MediaFormat.KEY_MIME);
                Log.d(TAG, "Mime for track " + j + " of frame " + FRAME_TO_EXTRACT + ": " + mime);
                if (mime.startsWith("audio/")) {
                    extractor.selectTrack(j);

                    ByteBuffer csd0Buffer = format.getByteBuffer("csd-0");
                    csd0 = Arrays.copyOf(csd0Buffer.array(), csd0Buffer.array().length);
                    samplingRate = format.getInteger(MediaFormat.KEY_SAMPLE_RATE);
                    numChannels = format.getInteger(MediaFormat.KEY_CHANNEL_COUNT);

                    break;
                }
            }
            extractor.release();

        } catch (IOException e) {
            e.printStackTrace();
        }

        Log.d(TAG, "MediaExtractor extracted audio meta info from frame " + FRAME_TO_EXTRACT + "." + "\n" +
                "csd-0 contents: " + Helpers.bytesToHex(csd0) + "\n" +
                "KEY_SAMPLE_RATE: " + samplingRate + "\n" +
                "KEY_CHANNEL_COUNT: " + numChannels
        );

        MediaFormat format = makeAACCodecSpecificData(MediaCodecInfo.CodecProfileLevel.AACObjectLC, samplingRate, numChannels);

        Log.d(TAG, "MediaFormat meta info generated by makeAACCodecSpecificData from frame " + FRAME_TO_EXTRACT + "." + "\n" +
                "csd-0 contents: " + Helpers.bytesToHex(format.getByteBuffer("csd-0").array()) + "\n" +
                "KEY_SAMPLE_RATE: " + format.getInteger(MediaFormat.KEY_SAMPLE_RATE) + "\n" +
                "KEY_CHANNEL_COUNT: " + format.getInteger(MediaFormat.KEY_CHANNEL_COUNT)
        );

        MediaCodec decoder = null;
        try {
            decoder = MediaCodec.createDecoderByType("audio/mp4a-latm");
        } catch (IOException e) {
            e.printStackTrace();
        }
        decoder.configure(format, null, null, 0);

        Log.d(TAG, "Output format of decoder: " + AudioProcessingHelpers.getPCMEncodingString(decoder.getOutputFormat()));

        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        decoder.start();

        Log.d(TAG, "Successfully started decoder.");

        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        for (int currentFrameIndex = 0; currentFrameIndex < TestFrames.MUSIC_ADTS_FRAME_BUFFERS.length; currentFrameIndex++) {
            Log.d(TAG, "Trying to dequeue input buffer for frame " + currentFrameIndex + "...");
            int inputBufferId = decoder.dequeueInputBuffer(INFINITE_WAIT);
            Log.d(TAG, "Successfully dequeued input buffer for frame " + currentFrameIndex);
            if (inputBufferId >= 0) {
                Log.d(TAG, "Index of input buffer dequeued: " + inputBufferId);

                try {
                    Thread.sleep(5000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

                ByteBuffer inputBuffer = decoder.getInputBuffer(inputBufferId);
                byte[] currentFrame = TestFrames.MUSIC_ADTS_FRAME_BUFFERS[currentFrameIndex];
                inputBuffer.put(Arrays.copyOfRange(currentFrame, 7, currentFrame.length - 7));
                Log.d(TAG, "Filled input buffer " + inputBufferId);

                try {
                    Thread.sleep(5000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

                decoder.queueInputBuffer(inputBufferId, 0, currentFrame.length - 7,
                                         AudioProcessingHelpers.getPresentationTime(
                                                currentFrameIndex,
                                                format.getInteger(MediaFormat.KEY_SAMPLE_RATE),
                                                AudioProcessingHelpers.AAC_ADTS_SAMPLES_PER_FRAME),
                                    0);
                Log.d(TAG, "Queued input buffer " + inputBufferId);

                try {
                    Thread.sleep(5000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            MediaCodec.BufferInfo bufferInfo = new MediaCodec.BufferInfo();
            Log.d(TAG, "Trying to dequeue output buffer for frame " + currentFrameIndex + "...");
            int outputBufferId = decoder.dequeueOutputBuffer(bufferInfo, INFINITE_WAIT);
            Log.d(TAG, "Successfully dequeued output buffer for frame " + currentFrameIndex);
            if (outputBufferId >= 0) {
                Log.d(TAG, "Index of output buffer dequeued: " + outputBufferId);
                ByteBuffer outputBuffer = decoder.getOutputBuffer(outputBufferId);
                Log.d(TAG, "Contents of output buffer dequeued: " + Helpers.bytesToHex(outputBuffer.array()));
                decoder.releaseOutputBuffer(outputBufferId, false);
            } else if (outputBufferId == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {
                Log.d(TAG, "Output format of decoder changed, new output format: " +
                        AudioProcessingHelpers.getPCMEncodingString(decoder.getOutputFormat()));
            } else if (outputBufferId == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {
                Log.d(TAG, "Got an INFO_OUTPUT_BUFFERS_CHANGED from the media codec (this shouldn't be happening, this is " +
                        "stated to be deprecated in the documentation.)");
            }
        }
        decoder.stop();
        decoder.release();

    }

    /**
     * The code profile, Sample rate, channel Count is used to
     * produce the AAC Codec SpecificData.
     * Android 4.4.2/frameworks/av/media/libstagefright/avc_utils.cpp refer
     * to the portion of the code written.
     *
     * MPEG-4 Audio refer : http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio#Audio_Specific_Config
     *
     * @param audioProfile is MPEG-4 Audio Object Types
     * @param sampleRate
     * @param channelConfig
     * @return MediaFormat
     */
    private MediaFormat makeAACCodecSpecificData(int audioProfile, int sampleRate, int channelConfig) {
        MediaFormat format = new MediaFormat();
        format.setString(MediaFormat.KEY_MIME, "audio/mp4a-latm");
        format.setInteger(MediaFormat.KEY_SAMPLE_RATE, sampleRate);
        format.setInteger(MediaFormat.KEY_CHANNEL_COUNT, channelConfig);

        int samplingFreq[] = {
                96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050,
                16000, 12000, 11025, 8000
        };

        // Search the Sampling Frequencies
        int sampleIndex = -1;
        for (int i = 0; i < samplingFreq.length; ++i) {
            if (samplingFreq[i] == sampleRate) {
                Log.d("TAG", "kSamplingFreq " + samplingFreq[i] + " i : " + i);
                sampleIndex = i;
            }
        }

        if (sampleIndex == -1) {
            return null;
        }

        ByteBuffer csd = ByteBuffer.allocate(2);
        csd.put((byte) ((audioProfile << 3) | (sampleIndex >> 1)));

        csd.position(1);
        csd.put((byte) ((byte) ((sampleIndex << 7) & 0x80) | (channelConfig << 3)));
        csd.flip();
        format.setByteBuffer("csd-0", csd); // add csd-0

        Log.d(TAG, "Value of csd-0 array generated by makeAACCodecSpecificData: " + Helpers.bytesToHex(csd.array()));

        return format;
    }

}
